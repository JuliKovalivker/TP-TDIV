def service_connection(key, mask, modo, archivo_descarga=None):
    sock = key.fileobj
    data = key.data
    try:
        if mask & selectors.EVENT_READ:
            # Si hay datos recibidos los voy guardando
            recv_data = sock.recv(4096)
            if not recv_data:
                sel.unregister(sock)
                sock.close()
                return
            data.inb += recv_data
            header_end = data.inb.find(b"\r\n\r\n")
            if header_end == -1:
                return
            headers_raw = data.inb[:header_end]
            try:
                headers = headers_raw.decode("utf-8", errors="ignore")  # Decodifico el header
            except UnicodeDecodeError:
                print("Error al decodificar headers.")
                sel.unregister(sock)
                sock.close()
                return
            content_length = 0
            for line in headers.split("\r\n"):
                if line.lower().startswith("content-length:"):
                    try:
                        content_length = int(line.split(":")[1].strip())
                    except ValueError:
                        pass
                    break
            expected_total_length = header_end + 4 + content_length
            if len(data.inb) < expected_total_length:
                return
            request_complete = data.inb
            
            # Separar request_line, headers y body
            request_line = headers.split("\r\n")[0]     # Primera linea del header tiene la request
            method = request_line.split(" ")[0]         # Primer dato del header => metodo
            path = request_line.split(" ")[1]           # Segundo dato del header => path
            body = request_complete[header_end + 4:]    # Segunda linea del header (luego de los dos enters) => body (no debe ser decodificado)

            response = None
            if method == "GET":
                if path == "/":
                    if modo:
                        html = generar_html_interfaz("upload").encode("utf-8")
                    else:
                        html = generar_html_interfaz("download").encode("utf-8")
                    response = (
                        "HTTP/1.1 200 OK\r\n"
                        "Content-Type: text/html; charset=utf-8\r\n"
                        f"Content-Length: {len(html)}\r\n"
                        "Connection: close\r\n"
                        "\r\n"
                    ).encode() + html
                elif path == "/download" and not modo and archivo_descarga:
                    response = manejar_descarga(archivo_descarga, request_line)
            elif method == "POST" and modo:
                boundary = None
                for line in headers.split("\r\n"):
                    if "Content-Type:" in line and "multipart/form-data" in line:
                        try:
                            boundary_part = line.split("boundary=")[1].strip() # Limpiar espacio o caracteres no deseados del boundary
                            boundary = boundary_part.strip('"') 
                            break
                        except IndexError:
                            pass
                if boundary:
                    html = manejar_carga(body, boundary, directorio_destino="archivos_servidor") # Ya puedo cargar el archivo
                else:
                    html = b"<html><body><h1>Error: boundary no encontrado o Content-Type incorrecto.</h1></body></html>"
                response = (
                    "HTTP/1.1 200 OK\r\n"
                    "Content-Type: text/html; charset=utf-8\r\n"
                    f"Content-Length: {len(html)}\r\n"
                    "Connection: close\r\n"
                    "\r\n"
                ).encode() + html
            if response is None:
                response = (
                    "HTTP/1.1 404 Not Found\r\n"
                    "Content-Type: text/plain\r\n"
                    "Connection: close\r\n"
                    "\r\n"
                    "Ruta no encontrada"
                ).encode()
            sock.sendall(response)
            sel.unregister(sock)
            sock.close()
    except ConnectionResetError:
        print("Se cerro la conexion.")
        try:
            sel.unregister(sock)
        except Exception:
            pass
        sock.close()